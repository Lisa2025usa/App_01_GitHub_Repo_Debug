@* Updated: 2025-12-06 21:40 PST - Tick recorder panel with shared test-panel styles *@

@using TradingAppProject.Service.MarketData
@inject ITickSource_Recorder_Service TickRecorder
@implements IDisposable

<div class="test-panel-header">
    <h4>Tick Recorder - Recent Ticks</h4>
    <p class="test-panel-summary">
        Showing last @Var_MaxCount ticks since
        @if (Var_LastClearedUtc == DateTime.MinValue)
        {
            @:session start
        }
        else
        {
            @Var_LastClearedLocal
        }
        . Recorder buffer: @TickRecorder.Count total. Local snapshot: @Var_Ticks.Count ticks.
    </p>
</div>

<div class="test-panel-controls">
    <button type="button"
            class="test-panel-button"
            @onclick="ClearTicks">
        Clear Recorder Buffer
    </button>
</div>

@if (Var_Ticks == null || Var_Ticks.Count == 0)
{
    <div class="test-panel-empty">
        No recorded ticks yet.
    </div>
}
else
{
    <div class="test-panel-ticks">
        <table class="test-panel-tick-table">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Time (Local)</th>
                    <th>Symbol</th>
                    <th>Bid</th>
                    <th>Ask</th>
                    <th>Last</th>
                </tr>
            </thead>
            <tbody>
                @for (int i = 0; i < Var_Ticks.Count; i++)
                {
                    MarketTick tick = Var_Ticks[i];

                    <tr>
                        <td>@(i + 1)</td>
                        <td>@tick.TimestampUtc.ToLocalTime()</td>
                        <td>@tick.Symbol</td>
                        <td>@tick.Bid</td>
                        <td>@tick.Ask</td>
                        <td>@tick.Last</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code
{
    private IReadOnlyList<MarketTick> Var_Ticks = Array.Empty<MarketTick>();
    private int Var_MaxCount = 200;

    private bool Var_IsRunning = false;
    private PeriodicTimer? Var_Timer;

    // Marks the "start" of the current visible session
    private DateTime Var_LastClearedUtc = DateTime.MinValue;

    // Local diagnostic: when the Clear button was last pressed (local time)
    private DateTime? Var_LastClearedLocal = null;

    protected override void OnInitialized()
    {
        Var_IsRunning = true;
        Var_Timer = new PeriodicTimer(TimeSpan.FromSeconds(1));

        // First snapshot for initial render
        Var_Ticks = GetFilteredTicks();

        _ = RefreshLoop();
    }

    private async Task RefreshLoop()
    {
        if (Var_Timer is null)
        {
            return;
        }

        while (Var_IsRunning && await Var_Timer.WaitForNextTickAsync())
        {
            Var_Ticks = GetFilteredTicks();
            await InvokeAsync(StateHasChanged);
        }
    }

    private IReadOnlyList<MarketTick> GetFilteredTicks()
    {
        // Get up to Var_MaxCount ticks from the recorder
        var raw = TickRecorder.GetRecentTicks(Var_MaxCount);

        // If we have never "cleared", just return them as-is
        if (Var_LastClearedUtc == DateTime.MinValue)
        {
            return raw;
        }

        // Otherwise, only show ticks that arrived after the last Clear
        var filtered = raw
            .Where(tick => tick.TimestampUtc >= Var_LastClearedUtc)
            .ToList();

        return filtered;
    }

    private async void ClearTicks()
    {
        // Clear underlying buffer
        TickRecorder.Clear();

        // Mark the "new session" start time (UTC + local)
        var nowLocal = DateTime.Now;
        Var_LastClearedLocal = nowLocal;
        Var_LastClearedUtc = nowLocal.ToUniversalTime();

        // Clear local snapshot immediately
        Var_Ticks = Array.Empty<MarketTick>();

        // Force an immediate UI refresh so rows disappear right away
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        Var_IsRunning = false;

        if (Var_Timer is not null)
        {
            Var_Timer.Dispose();
        }
    }
}
