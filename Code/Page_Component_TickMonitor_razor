@* Updated: 2025-12-07 01:45 PST - Tick monitor panel aligned with shared test-panel styles *@

@using TradingAppProject.Service.MarketData
@inject TickSource_Manager_Service TickSourceManager
@implements IDisposable

<div class="test-panel-header">
    <h4>@Par_Title</h4>
    <p class="test-panel-summary">
        @if (string.IsNullOrWhiteSpace(Par_SymbolFilter))
        {
            @:Showing all symbols from latest snapshot.
        }
        else
        {
            @:Filtered to symbol: @Par_SymbolFilter.
        }
        Currently tracking @_snapshot.Count symbol(s). Displaying @_filteredTicks.Count tick(s).
    </p>
</div>

@if (_filteredTicks.Count == 0)
{
    <div class="test-panel-empty">
        No ticks received yet.
    </div>
}
else
{
    <div class="test-panel-ticks test-panel-tick-monitor">
        <table class="test-panel-tick-table">
            <thead>
                <tr>
                    <th>Symbol</th>
                    <th>Last</th>
                    <th>Bid</th>
                    <th>Ask</th>
                    <th>Time (Local)</th>
                </tr>
            </thead>
            <tbody>
                @foreach (MarketTick tick in _filteredTicks)
                {
                    <tr>
                        <td>@tick.Symbol</td>
                        <td>@tick.Last</td>
                        <td>@tick.Bid</td>
                        <td>@tick.Ask</td>
                        <td>@tick.TimestampUtc.ToLocalTime()</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code
{
    // ----- Parameters -----

    /// <summary>
    /// Title displayed above the tick monitor panel.
    /// </summary>
    [Parameter] public string Par_Title { get; set; } = "Live Tick Monitor";

    /// <summary>
    /// Optional symbol filter. If set (e.g. "EUR/USD" or "MESZ5.CME"),
    /// only ticks for that symbol will be shown. If null/empty, all
    /// symbols in the snapshot are displayed.
    /// </summary>
    [Parameter] public string? Par_SymbolFilter { get; set; }

    // ----- Internal state -----

    private IReadOnlyDictionary<string, MarketTick> _snapshot =
        new Dictionary<string, MarketTick>();

    private List<MarketTick> _filteredTicks = [];

    protected override void OnInitialized()
    {
        // Initial snapshot
        _snapshot = TickSourceManager.GetSnapshot();
        RebuildFilteredTicks();

        // Subscribe for live updates (OnTickUpdated is Action<MarketTick>)
        TickSourceManager.OnTickUpdated += HandleTick;
    }

    // Must match Action<MarketTick>: returns void, takes MarketTick
    private void HandleTick(MarketTick tick)
    {
        _snapshot = TickSourceManager.GetSnapshot();
        RebuildFilteredTicks();

        // Just schedule a UI refresh; we don't need to await it
        _ = InvokeAsync(StateHasChanged);
    }

    private void RebuildFilteredTicks()
    {
        IEnumerable<KeyValuePair<string, MarketTick>> query =
            _snapshot.OrderBy(kvp => kvp.Key);

        if (!string.IsNullOrWhiteSpace(Par_SymbolFilter))
        {
            query = query.Where(kvp =>
                string.Equals(kvp.Key, Par_SymbolFilter, StringComparison.OrdinalIgnoreCase));
        }

        _filteredTicks = [.. query.Select(kvp => kvp.Value)];
    }

    public void Dispose()
    {
        TickSourceManager.OnTickUpdated -= HandleTick;
    }
}
